ThinkPHP5.0 + 小程序商城构建全栈应用
=====================================
## 第一大章
### 1-1:课程内容和产品所用到的技术
+ ThinkPHP5.0	
+ MySQL
+ 微信支付
+ 小程序

### 1-2:课程流程与体系
1. 服务端:ThinkPHP5 + MySQL构建REST API.
2. 客户端:[小程序/IOS/Andriod等等应用程序,很灵活的替换]
向服务端请求数据,完成自身行为逻辑[给用户使用的].
3. CMS:[数据管理的作用]
向服务端请求数据,实现发货与发送微信消息[给管理人员使用的].

### 总结下CMS的功能
+ 两大类
1. 基础数据的增删改查,比如:添加商品，删除商品
2. 特殊操作，比如我们要实现的发送微信消息

1-4:扩展课程:三端分离
+ CMS从服务端分离开后,实际上CMS也是一个客户端的应用程序了

1-5:项目特点
## 标准的REST API是基于资源的
+ 项目的权限是基于Token令牌管理权限的,我们的接口是有作用域概念的,就是分人访问的
+ 基于Token的用户认证的
+ 这套架构可以适配ios、Andriod、小程序与单页面[web代表]应用
+ 真正理解MVC
+ AOP面向切面编程思想在真实项目中的应用
+ 使用ORM的方式与数据库交互
+ MySQL数据表设计与数据冗余的合理利用
+ 用面向对象的思维构建前端代码(ES6 class&Module)

1-6:TP5技术点简介
+ Web框架三大核心知识(路由、控制器与模型)
+ 验证器、读取器、缓存与全局异常处理
+ ORM:模型与模型关联

1-7：微信技术点简介
+ 微信小程序
+ 微信登录
+ 微信支付(预订单、库存量检测与回调通知处理)
+ 微信模板消息

1-8:MySql技术点简介
+ 数据库表设计
+ 数据冗余的合理使用
+ 事务与锁在订单(库存量)检测中的应用[一个产品时,有两个用户同时下单成功并支付了]

1-9:学习方式

1-10:前置知识需求
+ PHP与面向对象的相关知识
+ ThinkPHP 基础知识(对控制器和路由的了解)
+ 了解关系数据库的基本使用,写过sql语句
+ 小程序常用API
+ 要有一个小程序账号

1-11:扩展课程 理解Web与前端
+ 泛化的web.网站不是web的全部,只是web的一小部分
+ 能写出代码和写出易维护的代码不是一回事儿[可复用性,易读性]

1-12:扩展课程 第三方组件应该合理选择,特别是在学习阶段
依赖或者包管理
+ composer:管理包与包之间的依赖关系的
+ npm
+ pip

1-13:维护与提问

## 第二大章
2-1:环境与工具

2-4:三端命名与运行ThinkPHP5
# 项目独立命名
+ 服务器程序:Zerg
+ 客户端小程序:Protoss
+ cms:Terran

2-5:PHPStorm安装以及常用使用技巧[就是一些快捷键]

2-7:TP5自带的Web Server[也没有什么用哦]

2-8 :在phpstorm下断点调试代码[xdebug调试工具] [我个人觉得没有什么用哦]

2-9 :PATH_INFO URL路由模式解析
+ 不区分大小写
+ 太长
+ url路径暴露了服务器结构
+ 不够灵活[根据你的文件目录结构来设置的],不能很好的支持url语义化[最大的缺陷]

## 第三大章

3-2 :就是配置虚拟域名,在本地

3-4 :三种url访问模式
+ pathinfo模式  module/controller/functionname
+ 路由访问Route::rule();当你在路由文件里配置了访问方法时,之前的pathinfo模式就不能访问了.
+ 混合模式:既可以使用pathinfo也可以使用路由模式
+ 强制使用路由模式,即只能使用路由模式
####在配置文件里配置路由访问

3-5 :定义路由

3-6 :获取请求参数
+ 方法体参数获取,($id,$name,$age)
+ Request类获取,静态类,门面类的使用

3-7 :产品功能讲解与分析
+ 自己问自己问题,自己来回答

3-8 :Navicat安装以及数据库设计初步分析

# 第四大章
4-1 :Banner数据表设计分析
+ 删除数据时不是物理删除,给了一个标识符
+ 一个banner位下面有4张banner图
+ banner表与banner_item是一对多的关系,即一个banner会对应多个banner_item的,而一个banner_item只能属于一个banner的.

4-2 :Banner接口定义及自定义控制器多级目录

4-3 :Validate独立验证,就是在控制器里写
+ 批量验证的使用 $validate->batch()->check($data)
+ var_dump($validate->getError())

4-4 :Validate验证器的使用

4-5 :零食贩结构体系详解
+ api 请求参数正确才继续访问,不正确直接拒绝

4-6 :自定义验证规则

4-7 :工欲善其事必先利其器,构建接口参数校验层[重点]

5-1 :介绍下REST之前的重要协议SOAP
##### 什么是REST:
+ Representational State Transfer:表述性状态转移
+ 一种风格、约束、设计理念

##### SOAP:Simple Object Access Protocol
+ 重
+ 通常来说,使用XML描述数据

5-2:RESTFul API的特点解析
+ 基于REST的API设计理论
+ 轻
+ 通常来说,使用JSON描述数据
+ 无状态,就是http请求与http请求之间是没有联系的
+ 基于资源,增删改查都只是对于资源状态的改变
+ 使用HTTP动词来操作资源[get,post...]
+ /getmovie/:mid [不推荐]   /movie/:mid

5-3:RESTFul API的最佳实践
+ POST:创建
+ GET:查询
+ DELETE:删除
+ PUT:更新
+ 状态码:404、400、200、201、202、401、403、500
+ 错误码:自定义的错误ID号
+ 统一描述错误:错误码、错误信息、产生错误信息的当前url
+ 使用Token令牌来授权和验证身份
+ API版本控制,版本号
+ 测试与生产环境分开:api.xxx.com
					 dev.api.xxx.com
+ URL语义要明确,最好可以望文知意
+ 最好有一份比较标准的文档

5-4:如何学习RESTFul API的设计
>学习RESTFul API的最佳方式
+ 模仿:推荐模仿豆瓣开放API
+ Github开放者API,这个是比较标准的
+ RESTFul API的合理使用(切勿盲目照搬标准REST)

# 第六大章:AOP与全局处理异常
6-1:正确理解异常处理流程
+ 快速移除无用的命名空间 ctrl+alt+o
+ 查询数据时有没有考虑过数据库异常或者没有这条数据时
+ 一定要记录日志,记录未知错误
+ 统一的错误返回信息格式

6-2:固有的处理异常的思维模式与流程
+ 200不是指正确的响应,而是正确拿到你想要的结果
+ 如果有很多异常,很多异常是不可预知的,有的错误不会去try catch
+ 有的错误是不需要返回客户端的,比如1/0,我们服务端只需悄悄记录下这个错误就行了

6-3: 理清思路，总结异常的分类
+ 什么时候需要向客户端返回错误信息,什么时候需要记录日志
#### 异常分类
1. 由于客户行为导致的异常(没有通过验证器,没有查询到结果);通常不需要记录日志,需要向客户返回具体信息
2. 服务器自身异常(代码错误,调用外部接口错误);通常记录日志,不需要向客户端返回具体信息

6-4: 实现自定义全局异常处理 上  [重点]
+ 当你定义了异常类时,要去app.php中exception_handle里加进去

6-5: 实现自定义全局异常处理 下 [重点]

6-6: ThinkPHP5中的日志系统
+ tp5会自动记录日志信息
+ 如何关闭tp自动记录日志功能
+ 全局记录日志

6-7: 在全局异常处理中加入日志记录
+ 这里有点问题,因为视频上讲解的是tp5.0的

6-8 全局异常处理的应用 上
6-9 全局异常处理的应用 中
6-10 全局异常处理的应用 下
6-11 本章小结与AOP思想
+ AOP面向切面编程
+ 比如买电影票:不管是在哪里买的票,都要到统一的检票口进行检票

# 第七大章:数据库访问与ORM
7-2 从一个错误了解Exception的继承关系
+ HttpException不能自动转换成think\Exception类型
+ 如果能自动转换,说明它是think\Exception的子类

7-7 开启sql日志记录
+ database.php中的debug要是true
+ log.php中,日志记录级别 'level'=> ['sql']
+ 开发环境建议开启,生产环境建议关闭,因为写入也要耗费服务器性能的
+ sql性能分析,阿里云的产品,可以查看你项目中的哪条sql耗时长

7-8 ORM与模型
+ ORM:Object Relation Model 对象关系映射
+ 把每一张表理解成一个对象
+ 操作的并不是数据库的表,操作的是一个对象了
+ 表与表之间的关系就变成了对象与对象之间的关系了
+ 模型不仅仅用来查询数据,还可以用来完成业务逻辑,是一个业务的集合
+ 模型是根据你的业务逻辑来划分的
+ 不要把模型单理解成数据查询
+ 不要把模型与数据库表一一对应起来,复杂的可能对应多个表
+ 模型不仅仅只有model这一层,可以有service层,login层...,业务逻辑可以划分为多层的

7-9 初始模型
+ 当你登陆不在你常用登陆地,会发短信你;还有在多个设备上登陆
+ 还有当你在pc端登陆了,移动端就会下线,这是db类就很吃力了
+ 用ORM来重载我们的业务逻辑
+ db通常不能很好的包含和处理我们的业务逻辑
+ db属于数据库访问层,model是建立在数据库之上的业务逻辑层
+ model定义:要继承think\model
+ 使用Model来查询数据时,返回是一个模型对象,不是数组
+ 涉及到框架的默认行为,就去配置文件找
+ 当你用模型查询出数据时,直接return $模型值时,返回的是html格式的;当你用return json($model_value)
  时,返回的是json格式的;这时你可以去配置文件修改默认返回的格式为json格式的

7-10 模型定义总结
+ 一个模型一般对应一个表,通常是这样的;但实际上一个模型可能关联多张表;即关联模型
+ 主从表,映射到ORM对象中,就是用关联模型的方法来实现主从表
+ 默认情况下,模型名称与数据表名称是一样的, 也并不是表名就等于模型名的
    
7-11 静态调用还是实例对象调用
+ 推荐使用静态调用方式查询数据
+ Model::get(主键)
+ 数据库基本单位是表以及表里的一条条记录
+ 在ORM里,当你实例化某个模型时,它才代表数据库中的某张表

7-12 几种查询动词的总结与ORM性能问题的探讨
1. Db是模型的基石,它两是有关系的,模型可以用Db查询数据的方法
2. 模型与数据库访问层是两个不同的概念,它主要是用来处理业务逻辑的
3. 不要因为模型的性能稍差,就放弃使用模型
4. 我们要用面向对象的思维来设计模型
5. 模型底层仍然是数据库访问抽象层
#### 关于模型性能:
1. 它的性能稍慢,性能是决定使用它的因素吗, 可控范围内
2. 慢是因为sql语句写的不好
3. 当涉及到很多量时,即高并发时,就建议使用原生sql
4. 物理硬件性能的提升也可以改变性能

# 第八大章
8-1 Banner相关表分析（数据表关系分析）
+ banner是主表,banner_item是从表,它两是主从表的关系
+ 首页banner是banner_item的信息的
+ 他们之间关联项是banner_id
+ 一个banner位可以有很多的banner_item,一个banner_item不能属于多个banner位的,它们才属于一对多
+ 数据表与数据表之间的关系取决于你的业务逻辑
+ 确定两个表之间的关系:
> 先排除它们是不是多对多的
> 看两张表中的关联字段取值有没有重复
> 一对多查询出来的数据是多维的,一对一是一维数组

8-2 模型关联----定于关联与查询关联
+ banner_item是附属在banner上的,通过查询banner来查询出banner_item的信息

8-3 模型关联----嵌套关联查询
+ 如果banner还和其他表有关联的话,再定义一个方法就好了
+ 通过banner_item关联img拿出img表中的信息
+ banner关联banner_item，banner_item再去关联Image,这属于嵌套关联

8-4 隐藏模型字段
+ 隐藏多级字段,就是数据是多层的

8-5 在模型内部隐藏字段
+ 如果在很多地方调用banner_item数据接口时,想隐藏字段时,每个接口都加hiiden吗？
+ 在模型里设置protected $hidden的值就可以了

8-6 图片资源URL配置
+ 图片url应该是一个http或者https开头的一个完整的url路径
+ url:静态资源的方式存放到自己服务器,以相对路径的形式;云端oss和七牛云上
+ from:1表示存在本地服务器上的;2存在云端上的,完整的url路径,直接返回到客户端就好了
+ 服务器域名加上数据库的相对路径,组成一个完整的url才可以访问的到图片
+ public目录是公开的目录,是不需要权限的
+ 有没有一个办法是从模型里读取url路径时,就是完整的url路径?
+ tp5.1里想要自定义配置文件,直接在config目录里新建就好了
+ tp5.0 可以在application下新建一个extra文件夹,然后再去新建一个配置文件

8-7 读取器[获取器]的巧妙应用,这个很厉害
+ 我们不能认为我们所有的图片都是存放在本地服务器上的
+ 当from为2时,就说明图片来自于云端
+ 哪个模型要用读取器,就去哪个模型中新建读取器

8-8 自定义模型基类*
+ 在某个模型里新建读取器时,那么就会自动调用,但是其他表里面也有url字段时,读取器是无法生效的,所以
  新建一个模型基类,将读取器方法移到这里面来;但是还是有问题,当其他表中有url字段时,但是它不是url路径,
  它还是会执行读取器方法,那么这个行为不是正确的
+ 所以在基类模型中自定义一个获取url的方法,然后去要用读取器的模型中使用获取器方法去调用基类模型中的url获取方法

8-9 定义API版本号
#### 开闭原则:扩展是开放的,修改是封闭的
+ 有新版本时,新建一个版本文件夹去存放
+ 有一些用户不去使用新的,所以存在一个新老兼容的问题
+ 路由定义动态获取api版本号

8-10 专题接口模型分析
+ 一个专题下可以有很多产品,一个产品也可以对应多个专题
+ 所以这两个是属于多对多的关系,通常多对多要建立第三张中间表来处理两者之间的关系
+ 第三张表,我们没有必要去建立,tp会自动去处理之间的关系

8-11 一对一关系解析
+ 查询什么数据,就在哪个模型里定义关联关系
+ 一对一之间存在一个主从关系的,hasOne和belongsTo都代表一对一,是不能互换的
+ 外键关系建立在theme表中的,并没有建立在img表中,所以是不能互换的
+ 如果一个表中有关联字段,就是外键,那么就在这个模型里使用belongsTo;
  如果一个表中没有外键,或者是在它关联表中的,就是用hasOne

8-12 Theme接口验证与重构
+ 重复使用的验证规则提取到基类中

8-13 完成Theme简要信息接口
+ 凡是hidden关联的模型,都会隐藏

8-14 开启路由完整匹配模式
+ 路由是否完全匹配 'route_complete_match'   => true,

8-15 编写Theme详情接口

8-16 数据库字段冗余的合理利用 
+ 多对多的关系,查询出数据时,会自动产生pivot,属于中间表的属性

8-17 REST的合理利用  
+ 表与表之间有两个是记录相同的信息
+ 写入的时候也要写入两个相同的信息,还有更改时,数据的同步 
+ 客户端不需要用到的数据就隐藏起来

8-18 最近新品接口编写
+ 做法:将上传到数据库的商品时间按照倒序排列就好了
+ delete_time会记录你删除当前记录的时间,要使用模型来操作,才会自动写入
+ delete_time不是真正的删除,用一个标记位,delete_time有值说明之前已经删除过
+ 这里默认显示15条,客户端可以传值进来显示多少条,但是服务器也要有一个自我保护机制,不能客户端传进来1500条
  就去查询出1500条
  
8-19 使用数据集合(collection)还是数组？
+ 验证规则之间不要加空格 require | max:10
+ tp5.1 collection的用法,可以利用collection来隐藏字段吗?
+ 对空值的判断

8-20 分类列表接口编写

8-21 扩展：接口粒度与接口分层
+ 首页里要调用3个接口才能完整显示一个首页
+ 如果3个接口合为1个,弊端:
> 一个出了错,其他的可能都会出错

> 复用性差
+ 接口设计很复杂
+ API分层访问
+ 假如一个页面有20个接口,在API数据这层上再建立一个业务层 

8-22 分类商品接口编写
+ 针对分类来写,还是商品来写,REST基于资源的,所以我们就用模型的方式

# 第九大章
9-1 初始Token--意义与作用
+ 在前面的课程中,任何人都可以访问到我们的接口的
+ 有些接口可以公开访问,有的接口不能公开访问的
+ API的权限控制,确定用户身份,有些人可以访问,有些人不能访问
+ 我们用令牌来管理用户的身份

9-2 微信身份体系设计
+ openid不能传到客户端去,一定要存到服务器上





